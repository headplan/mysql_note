# 基础应用

#### MySQL体系结构

**什么是体系结构?**

体系结构包括一组部件以及部件之间的联系 .

**Mysql的部件有那些?**

![](/assets/mysqbujian.png)

**1.Connectors指的是不同语言中与SQL的交互,就是连接器**

简单说就是接口的客户端 .

比如上图中的Native C API, php,python等.

**2.Management Serveices & Utilities , 系统管理和控制工具**

mysql , mysqldump等 , 用来管理数据库,备份,恢复,安全控制等等 .

**3.Connection Pool : 连接池 . **

管理缓冲用户连接 , 线程处理,验证,安全,检查等需要缓存的需求 .

**4.SQL Interface : SQL接口**

接受用户的SQL命令 , 并且返回用户需要查询的结果 . 比如select from就是调用SQL Interface

**5.Parser : 解析器**

SQL命令传递到解析器的时候会被解析器验证和解析 . 主要功能 :

a . 将SQL语句分解成数据结构 , 并将这个结构传递到后续步骤 , 以后SQL语句的传递和处理就是基于这个结构的

b . 如果在分解构成中遇到错误 , 那么就说明这个sql语句是不合理的 . 比如经常遇到的1064的错误 , 也就是语法错误 .

**6.Optimizer : 查询优化器**

SQL语句在查询之前会使用查询优化器对查询进行优化 . 他使用的是“选取-投影-联接”策略进行查询 .

优化器会根据实际情况做一个预估和判断 , 解析SQL语句后 , 传给查询优化器 , 同样的SQL语句在数据量不一样的情况时 , 给出的查询优化方式也是不一样的 , 它会自动根据数据量去优化 . 比如联查时候 , 有两种索引都可以用 , 在数据量少的时候 , 优化器可能认为全表扫描比用索引更快 , 就会全表扫\(当然实际中一般不会这样\) , 当第一种索引比第二种索引好的时候 , 就优化为用索引一 . 或者左连和右连查的时候 , 也可能会转成内联的方式去查 . 这就是优化器的功能 .

用一个例子就可以理解： select uid,name from user where gender = 1;

这个select查询先根据where语句进行选取 , 而不是先将表全部查询出来以后再进行gender过滤

这个select查询先根据uid和name进行属性投影 , 而不是将属性全部取出以后再进行过滤

将这两个查询条件联接起来生成最终查询结果

**7.Cache和Buffer : 查询缓存**

如果查询缓存有命中的查询结果 , 查询语句就可以直接去查询缓存中取数据 .

这个缓存机制是由一系列小缓存组成的 . 比如表缓存 , 记录缓存 , key缓存 , 权限缓存等 .

**8.Engine : 存储引擎**

存储引擎是MySql中具体的与文件打交道的子系统 . 也是Mysql最具有特色的一个地方 .

Mysql的存储引擎是插件式的 . 它根据MySql AB公司提供的文件访问层的一个抽象接口来定制一种文件访问机制\(这种访问机制就叫存储引擎\)现在有很多种存储引擎 , 各个存储引擎的优势各不一样 , 最常用的MyISAM,InnoDB .

---

#### MySQL的各个功能模块中的执行过程

![](/assets/mysqljiagoutu.png)

**MySQL可以分为Server层和存储引擎层两部分**

**Server层包括**

* 连接器\(Connectors\)
* 查询缓存\(Cache , Buffer\)
* 分析器\(也叫解释器 , Parser\)
* 查询优化器\(Optimizer\)
* 执行器\(SQL接口 , SQL Interface\)

以及所有的内置函数\(如日期 , 时间 , 数学和加密函数等\) , 所有跨存储引擎的功能也都在这一层实现 , 比如存储过程 , 触发器 , 视图等 .

**存储引擎**

负责数据的存储和提取 . 架构模式是插件式的 , 支持InnoDB , MyISAM , Memory等 . MySQL5.5.5版本开始使用InnoDB作为默认的存储引擎 .

> 在create table语句中使用engine=memory来指定存储引擎 .

#### SQL执行流程

**连接器**

第一步 , 连接数据库 , 连接器负责跟客户端建立连接 , 获取权限 , 维持和管理连接 .

```
mysql -h$ip -P$port -u$user -p
```

生产环境建议交互对话输入密码 .

命令中的mysql是客户端工具 , 用来跟服务端建立连接 . TCP握手之后 , 连接器就开始认证你的身份了 , 用的就是输入的用户名和密码 .

* 用户名或密码不对 , 提示"Access denied for user"错误 , 然后客户端程序结束执行 .
* 如果认证通过 , 连接器会到权限表里查出账户拥有的权限 . 之后 , 这个连接里面的所有权限逻辑判断都依赖此时读到的这个权限 .

这就意味着 , 一个用户成功建立连接后 , 即使用管理员账号对这个用户的权限做了修改 , 也不会影响已经存在的连接权限 , 只有再新建的连接才会有新的权限设置 .

使用**show processlist**命令查看连接状态 .

![](/assets/showprocesslist.png)

Command中显示的Sleep就是表示一个空闲连接 . 这个时间使用wait\_timeout参数控制 , 默认8小时 , 如果太长时间没动静 , 连接器就自动断开了 .

**查询缓存**

连接简历完成后 , 就来带了执行逻辑的第二步 , **查询缓存** .

MySQL拿到一个查询请求后 , 会先到查询缓存 , 看看之前有没有执行过这条语句 . 执行过的语句以及结果存储为类似key-value对的形式 , 缓存在内存中 , 缓存命中 , 则直接返回给客户端 .

但是大多数情况下建议不要使用查询缓存 , 因为查询缓存往往弊大于利 . 因为其失效非常频繁 , 只要有对一个表的更新 , 这个表上所有的查询缓存都会被清空 , 所以对于更新压力大的数据库来说 , 命中率会非常低 .

当然 , MySQL提供了按需使用的方式 , 比如有一张静态表 , 例如系统配置 , 或者默认的分类列表等 , 很长时间才会更新一次 .

将参数query\_cache\_type设置为DEMAND , 默认情况SQL语句都不使用查询缓存 , 需要使用的 , 显式的指定SQL\_CACHE即可 :

```
mysql> select SQL_CACHE * from T where ID=10
```

> MySQL8.0版本直接将查询缓存的整块功能删掉了 .

**分析器**

如果没有缓存 , 接下来即要真正执行SQL语句了 , 首先就是对SQL语句的解析 , 就是分析器 .

分析器会做词法分析 , 分析输入的字符串空格组成的这条SQL语句 , 到底代表什么意思 . 例如 , Select关键字被识别为查询语句 . 语法错误则会提示 :

```bash
You have an error in your SQL syntax
```

检查sql的语法顺序等 ,

然后预处理器对解析树进一步分析 , 验证数据表、字段是否存在 , 内建解析树 , 对其语法检查 , 先from , 再on , 再join , 再where......检查权限等 . 这里其实还有一层 , **预处理器**进一步检查解析树的合法 . 比如 : 数据表和数据列是否存在 , 别名是否有歧义等 . 最后生成新的解析树 , 再提交给优化器 .

**优化器**

经过了分析器 , 在开始执行之前 , 还要经过优化器的处理 . 优化器是在表里面有多个索引的时候 , 决定使用哪个索引 , 或者在一个语句有多表关联的时候 , 决定各个表的连接顺序 . 即优化选择最优的方式执行语句 .

经过了优化器 , 语句的执行方案就确定下来了 , 然后进入执行器阶段 .

