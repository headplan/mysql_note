# 日志系统

SQL语句的更新语句的执行链路和查询的流程类似 . 也都会走一遍 .

执行语句前要先连接数据库 , 这是连接器的工作 . 在一个表上有更新的时候 , 更这个表有关系的查询缓存都会失效 , 这也是一般不建议使用查询缓存的原因 . 接下来分析器通过词法和语法解析得到这条更新语句 , 优化器决定要使用的索引字段 , 然后执行器负责具体的执行 , 找到这一行 , 更新内容 .

上面的内容可以看出 , 更新流程和查询流程基本一样 , 不同的地方是 , 更新流程涉及两个重要的日志模块 :

* redo log\(重做日志\)
* binlog\(归档日志\)

#### redolog

MySQL里经常说到的WAL技术 , 全程是Write-Ahead-Logging , 它的关键点就是先写日志 , 再写磁盘 , 就和饭店记账一样 , 先写到单子上 , 等不忙了的时候再写进账本里 .

具体来说 , 当有一条记录需要更新的时候 , InnoDB引擎就会把记录写到redo log里面 , 并更新内存 , 这时候更新就算完成了 . 同时 , InnoDB引擎会在适当的时候 , 将这个操作记录更新到磁盘里 , 而这个更新往往是在系统比较空闲的时候做 .

InnoDB的redo log是固定大小的 , 比如可以配置为一组4个文件 , 每个文件的大小是1GB . InnoDB就可以记录4GB的操作 , 从头开始写 , 写到末尾就又回到开头循环写 :

![](/assets/redolog.png)

write pos是当前记录的位置 , 一边写一边后移 , 写到第3号文件末尾后就回到0号文件开头 . checkpoint是当前要擦除的位置 , 也是往后推移并且循环的 , 擦除记录前要把记录更新到数据文件 .

write pos和checkpoint之间的存储空间是空着的部分 , 可以用来记录新的操作 . 如果write pos追上checkpoint , 表示redo log的大小已经满了 , 这个时候就不能再执行新的更新 , 得停下来先擦掉一些记录 , 把checkpoint推进一下 .

有了redo log , InnoDB就可以保证即使数据库发生异常重启 , 之前提交的记录都不会丢失 , 这个能力称为crash-safe .

#### binlog

MySQL整体来看分为两块 :

* 引擎层负责存储相关的具体事宜 . \(比如前面Innodb引擎特有的redolog\)
* Server层主要做的是 MySQL 功能层面的事情 . \(下面要说的binlog , 归档日志\)

历史回顾 :

> 最开始MySQL里并没有InnoDB引擎 , MySQL自带的引擎是MyISAM , 但是没有crash-safe能力 , binlog只能用于归档 . 而InnoDB是另一个公司以插件形式引入MySQL的 , 使用了有crash-safe能力的日志系统 , 也就是前面提到的redo log .

redolog和binlog的不同 :

* redo log 是 InnoDB 引擎特有的 ; binlog 是 MySQL 的 Server 层实现的 , 所有引擎都可以使用 . 
* redo log 是物理日志 , 记录的是"在某个数据页上做了什么修改" ; binlog 是逻辑日志 , 记录的是这个语句的原始逻辑 , 比如"给 ID=2 这一行的 c 字段加 1" . 
* redo log 是循环写的 , 空间固定会用完 ; binlog是可以追加写入的 . 意思是文件写到一定大小后会切换到下一个 , 并不会覆盖以前的日志 . 

执行器和InnoDB引擎在执行简单的update语句时的内部流程 :

1.执行器先找存储引擎取ID=2这一行 . ID是主键 , 存储引擎直接用树搜索找到这一行 . 如果ID=2这一行所在的数据页本来就在内存中 , 就直接返回给执行器 . 否则 , 需要先从磁盘读入内存 , 然后再返回 .

2.执行器拿到存储引擎给的行数据 , 把这个值加上1 , 比如原来是N , 现在就是N+1 , 得到新的一行数据 , 再调用引擎接口写入这行新数据 .

3.引擎将这行新数据更新到内存中 , 同时将这个更新操作记录到redo log里面 , 此时redo log处于prepare状态 . 然后告知执行器执行完成了 , 随时可以提交事务 .

4.执行器生成这个操作的binlog , 并把binlog写入磁盘 .

5.执行器调用引擎的提交事务接口 , 引擎把刚刚写入的 redo log 改成提交\(commit\)状态 , 更新完成 . 

![](/assets/redologtijiao.png)

