# 日志系统

SQL语句的更新语句的执行链路和查询的流程类似 . 也都会走一遍 .

执行语句前要先连接数据库 , 这是连接器的工作 . 在一个表上有更新的时候 , 更这个表有关系的查询缓存都会失效 , 这也是一般不建议使用查询缓存的原因 . 接下来分析器通过词法和语法解析得到这条更新语句 , 优化器决定要使用的索引字段 , 然后执行器负责具体的执行 , 找到这一行 , 更新内容 .

上面的内容可以看出 , 更新流程和查询流程基本一样 , 不同的地方是 , 更新流程涉及两个重要的日志模块 :

* redo log\(重做日志\)
* binlog\(归档日志\)

#### redo log

MySQL里经常说到的WAL技术 , 全程是Write-Ahead-Logging , 它的关键点就是先写日志 , 再写磁盘 , 就和饭店记账一样 , 先写到单子上 , 等不忙了的时候再写进账本里 .

具体来说 , 当有一条记录需要更新的时候 , InnoDB引擎就会把记录写到redo log里面 , 并更新内存 , 这时候更新就算完成了 . 同时 , InnoDB引擎会在适当的时候 , 将这个操作记录更新到磁盘里 , 而这个更新往往是在系统比较空闲的时候做 .

InnoDB的redo log是固定大小的 , 比如可以配置为一组4个文件 , 每个文件的大小是1GB . InnoDB就可以记录4GB的操作 , 从头开始写 , 写到末尾就又回到开头循环写 :

![](/assets/redolog.png)

write pos是当前记录的位置 , 一边写一边后移 , 写到第3号文件末尾后就回到0号文件开头 . checkpoint是当前要擦除的位置 , 也是往后推移并且循环的 , 擦除记录前要把记录更新到数据文件 . 

write pos和checkpoint之间的存储空间是空着的部分 , 可以用来记录新的操作 . 如果write pos追上checkpoint , 表示redo log的大小已经满了 , 这个时候就不能再执行新的更新 , 得停下来先擦掉一些记录 , 把checkpoint推进一下 . 

有了redo log , InnoDB就可以保证即使数据库发生异常重启 , 之前提交的记录都不会丢失 , 这个能力称为crash-safe . 

