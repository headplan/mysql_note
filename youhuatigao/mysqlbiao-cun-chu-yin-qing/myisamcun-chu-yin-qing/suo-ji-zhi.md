# MyISAM锁机制

**什么是锁机制?**

数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问变得有序所设计的一种规则 .

如果同时三个连接进来了 , 一个在执行

* a.update table  set  pos = 1  where  id =250;
* b.select pos from table where id =250;
* c.insert into table \(pos\) values \(12\);

那会发生什么事情?

#### 存储引擎的锁机制

MySQL有三种锁的级别：页级、表级、行级。

* MyISAM和MEMORY存储引擎采用的是表级锁\(table-level locking\)
* BDB存储引擎采用的是页面锁\(page-level locking\) , 但也支持表级锁
* InnoDB存储引擎既支持行级锁\(row-level locking\) , 也支持表级锁 , 但默认情况下是采用行级锁

MySQL这3种锁的特性可大致归纳如下 :

* 表级锁 : 开销小 , 加锁快 . 不会出现死锁 . 锁定粒度大 , 发生锁冲突的概率最高 , 并发度最低 . 
* 行级锁 : 开销大 , 加锁慢 . 会出现死锁 . 锁定粒度最小 , 发生锁冲突的概率最低 , 并发度也最高 . 
* 页面锁 : 开销和加锁时间界于表锁和行锁之间 . 会出现死锁 . 锁定粒度界于表锁和行锁之间 , 并发度一般 . 

#### MYISAM存储引擎的锁机制

MyISAM存储引擎只支持表锁 .

**查询表级锁争用情况**

可以通过检查`table_locks_waited`和`table_locks_immediate`状态变量来分析系统上的表锁定争夺 :

show status like 'table%' 查询锁的争用情况

Table\_locks\_waited的值如果比较高 , 说明存在着较严重的表级锁争用情况 . 怎么才算高? 常用的算法是 :

`table_locks_immediate/table_locks_waited < 5000`说明有比较验证的表锁的争夺情况 , 这时候可能就需要变更查询结构 , 存储引擎 , 或者增加机器等 .

![](/assets/biaosuochaxun.png)

**锁模式**

MySQL的表级锁有两种模式 : 表共享读锁\(Table Read Lock\)和表独占写锁\(Table Write Lock\) . 可以简单的理解为读锁和写锁 .

MyISAM在执行查询语句\(SELECT\)前 , 会自动给涉及的所有表加读锁 , 在执行更新操作\(UPDATE、DELETE、INSERT等\)前 , 会自动给涉及的表加写锁 .

所以对MyISAM表进行操作 , 会有以下情况 :

* a.对MyISAM表的读操作\(加读锁\) , 不会阻塞其他进程对同一表的读请求 , 但会阻塞对同一表的写请求 . 只有当读锁释放后 , 才会执行其它进程的写操作 . 
* b.对MyISAM表的写操作\(加写锁\) , 会阻塞其他进程对同一表的读和写操作 , 只有当写锁释放后 , 才会执行其它进程的读写操作 .

简单来说就是 :

读锁可以被读操作共享 , 不影响 , 但读锁会影响写操作 , 等读完了才能写 .

写锁会影响所有的读写操作 , 就是我写的时候 , 得等我写完了之后 , 你才能写或者读 .

