# MySQL索引和全文检索技术

所以的概念 , 就类似新华字典的目录 .

#### 索引的分类

1.普通索引 \(index\) , 用的最多的索引

2.唯一性索引 \(unique / primary\) , 唯一和主键

3.全文索引 \(fulltext\)

4.组合索引 , 几个字段组合成一个索引 .

**选择索引的点**

1. 如果没有唯一性要求,可以选择**普通索引**

2. 如果列上有唯一性要求,可以选择**唯一索引**

3. 如果是需要模糊搜索 , 建议选择**全文索引?**

4. 如果有多个条件一起查询 , 可以选择**组合索引**

**使用索引注意点**

1. 按需使用索引 , 索引添加过多是不好的 , 在插入或更新数据时 , 索引也会进行变更 , 索引越多 , 变更数据时候时间就越长 .

2. 索引所在的**列基数越大越好** , 男女这种字段建立索引的效果并不大 , 基数很小

3.在**组合索引**上要注意**最左原则** , 例如 , A,B,C三个字段 , 实际是创建了A , A+B , A+B+C的索引 , 当查询时用到了A+C索引时 , 实际只用了A的索引 , 当查询时用到了B+C , 这时候就用不到索引 . 当然sql语句的where条件的先后顺序不影响 , 比如先写where B , where C , where A , 是没有影响的 .

#### 索引的实现方式

如果有一个数组 array\(1,4,6,14,26,44,54,56,78,89,91\) , 查找89 , 常见的算法中可以了解到 :

* 顺序查找 - 重头找
* 二分法 - 从中间找
* 二叉查找树 - 思路和二分法一样 , 以树的结构去查找
* 平衡查找树 - 多叉树 , 让查询的层级变短 , 比而二叉查找树更快

**顺序查找**

简单点说就是做个循环 , 挨个比对 .

**二分法**

![](/assets/erfenchazhao.png)

**二叉查找树**

左子节点小于父节点 , 右子节点大于父节点 . 查数据怎么查呢 , 挨个节点比较 .

插入数据怎么查呢

先比较 , 后插入 , 插入的一定是叶子节点

删除怎么删除呢 , 分3种情况

* a.没有子树 , 直接删除
* b.只有一个子树的 , 将子节点的指针指向其爷爷节点
* c.两个子树的, 在右子树里找到最小的值对换后删除

**平衡查找树**

在满足二叉查找树的同时 , 要满足左右子树的高度差不能超过1 , 任何一个节点的子树都是平衡查找树

查数据怎么查呢 , 挨个节点比较

插入数据怎么查呢 ? 先比较 , 后插入 , 插入的

一定是叶子节点 , 插入完成后 , 可能就破坏了

平衡 , 这时就要旋转保持平衡 , 规则如下

* LL 新建在左子树的左节点上----右旋
* RR新建在右子树的右节点上----左旋
* LR新建在左子树的右节点上----先左后右
* RL新建在右子树的左节点上----先右后左

删除怎么删除呢 , 分3中情况

a.要删除的点没有子树 , 直接删除

b.只有一个子树的 , 直接删除 , 子节点指向父节点

c.两个子树的 , 如果该节点的平衡因子为0或者1 , 找到左子树中具有最大值的节点 , 然后交换 . 如果该节点的平衡因子为-1 , 则找到其右节点中具有最小值的节点min , 将min的内容与x的内容交换 , 现在要删除的点就是与a或b是相同情况了 .

![](/assets/erchahsu.png)

**b+树**

二叉查找树的特点是 , 左子节点小于父节点 , 右子节点大于父节点 .

平衡查找树的特点是在满足二叉查找树的基础上 , 还要满足任何左右两棵子树的高度差不能大于1

b+树由二叉平衡树演化而来 , 是多叉平衡术 , 所有的叶子节点都在一层上面

myisam引擎和innodb引擎都是使用的b+树\(b-树的变形\) , 但他们在机制上是不同的 .

* myisam : 叶节点的data域存放的是数据记录的地址 , MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引 , 如果指定的Key存在 , 则取出其data域的值 , 然后以data域的值为地址 , 读取相应数据记录 . \(非聚集索引\) . MyISAM索引文件和数据文件是分离的 , 索引文件仅保存数据记录的地址 . 
* 而在InnoDB中 , 表数据文件本身就是按B+Tree组织的一个索引结构 , 这棵树的叶节点data域保存了完整的数据记录 . 这个索引的key是数据表的主键 , 因此InnoDB表数据文件本身就是主索引 . \(这种方式的叫聚集索引 , 又叫聚簇索引\) . 

![](/assets/bjiashu.png)

#### 全文检索

全文检索只能在char , varchar 或 text等类型上建立 fulltext .

```
SELECT title FROM user where  MATCH(title, body) AGAINST ('who is WenZhang') ;
```

MATCH , 是要在那些字段上匹配数据 .

AGAINST , 匹配的内容是 .

上面的语句会在 title 上和 body 字段上查找相对应的数据 .

全文检索里 , 也有分词的概念 . 对应的数据是一个个的词 , 词由字母 , 数字和下划线和单引号组成 , 当我们的查询内容who is WenZhang 的时候 , mysql会帮我们分词 , 分成who / is / WenZhang , 这时候mysql会在title和body中查找包含这个三个词的数据 .

但是 , who 或着 is 不是我要查的内容 , 基本上我要查的就是WenZhang , 所以mysql在这块有个方式来处理 , 就是**stopword\(不查的词\)**和**词的长度** , 对英文来说 像the 这样的词就不用查 , 所以他在stopword中 , 而你自己设置的如 yxl 这样的词 , stopword肯定是不会存在的 , 所以mysql用词的长度来限制 , 当一个词的**长度小于等于3 或大于等于84** , 会被忽略掉 , 当然长度是可以调整的\(innodb\_ft\_min\_token\_size 和 innodb\_ft\_max\_token\_size\) .

全文检索也是索引的一部分 , 当然也是有存储引擎来实现 , myisam 在mysql3.2.x的版本上已经支持的全文索引 , innodb引擎在5.6.4版本也支持了全文索引 . 但是对中文支持的并不好 . 用全文索引搜中文只能得到全匹配结果 . 当然有其他的代替方案 , 比如sphinx , es等 . 如果非要使用mysql的全文索引 , 可以使用mysqlcft第三方插件 , 但是只能支持myisam引擎 . 



